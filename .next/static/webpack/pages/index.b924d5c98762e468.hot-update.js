"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/vsBot.ts":
/*!****************************!*\
  !*** ./src/utils/vsBot.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBotMove: () => (/* binding */ getBotMove),\n/* harmony export */   runVSBot: () => (/* binding */ runVSBot)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_ts_generator.js\");\n// VS Mode Bot Utility for Grid Royale\n// Supports: easy, medium, hard, legendary\n\n\n\n\n\n// --- Bot Logic for Each Difficulty ---\nfunction getRandomElements(arr, n) {\n    var shuffled = arr.slice().sort(function() {\n        return 0.5 - Math.random();\n    });\n    return shuffled.slice(0, n);\n}\nfunction easyBot(state) {\n    // Random guess, frequent mistakes, random burns\n    var guess = getRandomElements(state.words, 4);\n    var burn = Math.random() < 0.3 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction mediumBot(state) {\n    // Some logic: try to avoid obvious repeats, but still makes mistakes\n    var usedWords = new Set(state.solvedGroups.flat());\n    var available = state.words.filter(function(w) {\n        return !usedWords.has(w);\n    });\n    var guess;\n    if (Math.random() < 0.7) {\n        // Try to group by similarity (naive: first 4 unused)\n        guess = available.slice(0, 4);\n    } else {\n        // Random guess\n        guess = getRandomElements(available, 4);\n    }\n    var burn = Math.random() < 0.15 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction hardBot(state) {\n    // Pattern detection: try to find a real group, rare mistakes\n    var usedWords = new Set(state.solvedGroups.flat());\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = state.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var group = _step.value;\n            if (group.every(function(w) {\n                return !usedWords.has(w);\n            })) {\n                // Try to guess a real group\n                return {\n                    guess: group,\n                    burn: false\n                };\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // If no group found, rare random guess\n    var guess = getRandomElements(state.words.filter(function(w) {\n        return !usedWords.has(w);\n    }), 4);\n    var burn = Math.random() < 0.05 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction legendaryBot(state) {\n    // Near-perfect logic: always finds a real group if possible\n    var usedWords = new Set(state.solvedGroups.flat());\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = state.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var group = _step.value;\n            if (group.every(function(w) {\n                return !usedWords.has(w);\n            })) {\n                return {\n                    guess: group,\n                    burn: false\n                };\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // If no group left, burn only if wildcards exist\n    if (state.wildcards.length > 0) {\n        return {\n            guess: [],\n            burn: true\n        };\n    }\n    // Otherwise, random guess as fallback\n    return {\n        guess: getRandomElements(state.words.filter(function(w) {\n            return !usedWords.has(w);\n        }), 4),\n        burn: false\n    };\n}\nfunction getBotMove(difficulty, state) {\n    switch(difficulty){\n        case 'easy':\n            return easyBot(state);\n        case 'medium':\n            return mediumBot(state);\n        case 'hard':\n            return hardBot(state);\n        case 'legendary':\n            return legendaryBot(state);\n        default:\n            return easyBot(state);\n    }\n}\n/**\n * Simulates the bot playing the puzzle to completion, returning its solved groups, attempts left, and time taken.\n * Used in VSBotGame.tsx for bot progress display.\n */ function runVSBot(puzzle, difficulty) {\n    return _runVSBot.apply(this, arguments);\n}\nfunction _runVSBot() {\n    _runVSBot = (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_0__._)(function(puzzle, difficulty) {\n        var _loop, words, state, solvedGroups, attemptsLeft, start, timeMs;\n        return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_1__._)(this, function(_state) {\n            _loop = function() {\n                var move = getBotMove(difficulty, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_3__._)({}, state), {\n                    solvedGroups: solvedGroups,\n                    attemptsLeft: attemptsLeft\n                }));\n                if (move.guess.length === 0 && move.burn) {\n                    // Burn a wildcard if available\n                    if (state.wildcards.length > 0) {\n                        state.wildcards.pop();\n                    }\n                    attemptsLeft--;\n                    return \"continue\";\n                }\n                var groupMatch = puzzle.groups.find(function(group) {\n                    return move.guess.every(function(word) {\n                        return group.includes(word);\n                    });\n                });\n                if (groupMatch && !solvedGroups.some(function(g) {\n                    return g.every(function(word) {\n                        return groupMatch.includes(word);\n                    });\n                })) {\n                    solvedGroups.push(groupMatch);\n                    // Remove solved words from available words\n                    state.words = state.words.filter(function(w) {\n                        return !groupMatch.includes(w);\n                    });\n                } else {\n                    attemptsLeft--;\n                }\n                state.guesses.push(move.guess);\n            };\n            // Generate words array if not present\n            words = puzzle.words && Array.isArray(puzzle.words) ? (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.words) : (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.groups ? puzzle.groups.flat() : []).concat((0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.wildcards || []));\n            state = {\n                words: words,\n                groups: puzzle.groups,\n                guesses: [],\n                solvedGroups: [],\n                wildcards: (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.wildcards || []),\n                attemptsLeft: 4\n            };\n            solvedGroups = [];\n            attemptsLeft = 4;\n            start = Date.now();\n            while(solvedGroups.length < puzzle.groups.length && attemptsLeft > 0)_loop();\n            timeMs = Date.now() - start;\n            return [\n                2,\n                {\n                    solvedGroups: solvedGroups,\n                    attemptsLeft: attemptsLeft,\n                    timeMs: timeMs\n                }\n            ];\n        });\n    });\n    return _runVSBot.apply(this, arguments);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Qm90LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZTIE1vZGUgQm90IFV0aWxpdHkgZm9yIEdyaWQgUm95YWxlXG4vLyBTdXBwb3J0czogZWFzeSwgbWVkaXVtLCBoYXJkLCBsZWdlbmRhcnlcblxuZXhwb3J0IHR5cGUgQm90RGlmZmljdWx0eSA9XG5cdHwgJ2Vhc3knXG5cdHwgJ21lZGl1bSdcblx0fCAnaGFyZCdcblx0fCAnbGVnZW5kYXJ5JztcblxuZXhwb3J0IGludGVyZmFjZSBQdXp6bGVTdGF0ZSB7XG5cdHdvcmRzOiBzdHJpbmdbXTtcblx0Z3JvdXBzOiBzdHJpbmdbXVtdOyAvLyBTb2x1dGlvbiBncm91cHNcblx0Z3Vlc3Nlczogc3RyaW5nW11bXTsgLy8gUHJldmlvdXMgZ3Vlc3Nlc1xuXHRzb2x2ZWRHcm91cHM6IHN0cmluZ1tdW107XG5cdHdpbGRjYXJkczogc3RyaW5nW107XG5cdGF0dGVtcHRzTGVmdDogbnVtYmVyO1xuXHQvLyBBZGQgbW9yZSBhcyBuZWVkZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb3RNb3ZlIHtcblx0Z3Vlc3M6IHN0cmluZ1tdOyAvLyBUaGUgZ3JvdXAgb2Ygd29yZHMgdG8gZ3Vlc3Ncblx0YnVybj86IGJvb2xlYW47IC8vIFdoZXRoZXIgdG8gYnVybiBhIHdpbGRjYXJkXG59XG5cbi8vIC0tLSBCb3QgTG9naWMgZm9yIEVhY2ggRGlmZmljdWx0eSAtLS1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tRWxlbWVudHM8VD4oYXJyOiBUW10sIG46IG51bWJlcik6IFRbXSB7XG5cdGNvbnN0IHNodWZmbGVkID0gYXJyXG5cdFx0LnNsaWNlKClcblx0XHQuc29ydCgoKSA9PiAwLjUgLSBNYXRoLnJhbmRvbSgpKTtcblx0cmV0dXJuIHNodWZmbGVkLnNsaWNlKDAsIG4pO1xufVxuXG5mdW5jdGlvbiBlYXN5Qm90KHN0YXRlOiBQdXp6bGVTdGF0ZSk6IEJvdE1vdmUge1xuXHQvLyBSYW5kb20gZ3Vlc3MsIGZyZXF1ZW50IG1pc3Rha2VzLCByYW5kb20gYnVybnNcblx0Y29uc3QgZ3Vlc3MgPSBnZXRSYW5kb21FbGVtZW50cyhzdGF0ZS53b3JkcywgNCk7XG5cdGNvbnN0IGJ1cm4gPVxuXHRcdE1hdGgucmFuZG9tKCkgPCAwLjMgJiYgc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDA7XG5cdHJldHVybiB7IGd1ZXNzLCBidXJuIH07XG59XG5cbmZ1bmN0aW9uIG1lZGl1bUJvdChzdGF0ZTogUHV6emxlU3RhdGUpOiBCb3RNb3ZlIHtcblx0Ly8gU29tZSBsb2dpYzogdHJ5IHRvIGF2b2lkIG9idmlvdXMgcmVwZWF0cywgYnV0IHN0aWxsIG1ha2VzIG1pc3Rha2VzXG5cdGNvbnN0IHVzZWRXb3JkcyA9IG5ldyBTZXQoc3RhdGUuc29sdmVkR3JvdXBzLmZsYXQoKSk7XG5cdGNvbnN0IGF2YWlsYWJsZSA9IHN0YXRlLndvcmRzLmZpbHRlcihcblx0XHQodykgPT4gIXVzZWRXb3Jkcy5oYXModylcblx0KTtcblx0bGV0IGd1ZXNzOiBzdHJpbmdbXTtcblx0aWYgKE1hdGgucmFuZG9tKCkgPCAwLjcpIHtcblx0XHQvLyBUcnkgdG8gZ3JvdXAgYnkgc2ltaWxhcml0eSAobmFpdmU6IGZpcnN0IDQgdW51c2VkKVxuXHRcdGd1ZXNzID0gYXZhaWxhYmxlLnNsaWNlKDAsIDQpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFJhbmRvbSBndWVzc1xuXHRcdGd1ZXNzID0gZ2V0UmFuZG9tRWxlbWVudHMoYXZhaWxhYmxlLCA0KTtcblx0fVxuXHRjb25zdCBidXJuID1cblx0XHRNYXRoLnJhbmRvbSgpIDwgMC4xNSAmJiBzdGF0ZS53aWxkY2FyZHMubGVuZ3RoID4gMDtcblx0cmV0dXJuIHsgZ3Vlc3MsIGJ1cm4gfTtcbn1cblxuZnVuY3Rpb24gaGFyZEJvdChzdGF0ZTogUHV6emxlU3RhdGUpOiBCb3RNb3ZlIHtcblx0Ly8gUGF0dGVybiBkZXRlY3Rpb246IHRyeSB0byBmaW5kIGEgcmVhbCBncm91cCwgcmFyZSBtaXN0YWtlc1xuXHRjb25zdCB1c2VkV29yZHMgPSBuZXcgU2V0KHN0YXRlLnNvbHZlZEdyb3Vwcy5mbGF0KCkpO1xuXHRmb3IgKGNvbnN0IGdyb3VwIG9mIHN0YXRlLmdyb3Vwcykge1xuXHRcdGlmIChncm91cC5ldmVyeSgodykgPT4gIXVzZWRXb3Jkcy5oYXModykpKSB7XG5cdFx0XHQvLyBUcnkgdG8gZ3Vlc3MgYSByZWFsIGdyb3VwXG5cdFx0XHRyZXR1cm4geyBndWVzczogZ3JvdXAsIGJ1cm46IGZhbHNlIH07XG5cdFx0fVxuXHR9XG5cdC8vIElmIG5vIGdyb3VwIGZvdW5kLCByYXJlIHJhbmRvbSBndWVzc1xuXHRjb25zdCBndWVzcyA9IGdldFJhbmRvbUVsZW1lbnRzKFxuXHRcdHN0YXRlLndvcmRzLmZpbHRlcigodykgPT4gIXVzZWRXb3Jkcy5oYXModykpLFxuXHRcdDRcblx0KTtcblx0Y29uc3QgYnVybiA9XG5cdFx0TWF0aC5yYW5kb20oKSA8IDAuMDUgJiYgc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDA7XG5cdHJldHVybiB7IGd1ZXNzLCBidXJuIH07XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZGFyeUJvdChzdGF0ZTogUHV6emxlU3RhdGUpOiBCb3RNb3ZlIHtcblx0Ly8gTmVhci1wZXJmZWN0IGxvZ2ljOiBhbHdheXMgZmluZHMgYSByZWFsIGdyb3VwIGlmIHBvc3NpYmxlXG5cdGNvbnN0IHVzZWRXb3JkcyA9IG5ldyBTZXQoc3RhdGUuc29sdmVkR3JvdXBzLmZsYXQoKSk7XG5cdGZvciAoY29uc3QgZ3JvdXAgb2Ygc3RhdGUuZ3JvdXBzKSB7XG5cdFx0aWYgKGdyb3VwLmV2ZXJ5KCh3KSA9PiAhdXNlZFdvcmRzLmhhcyh3KSkpIHtcblx0XHRcdHJldHVybiB7IGd1ZXNzOiBncm91cCwgYnVybjogZmFsc2UgfTtcblx0XHR9XG5cdH1cblx0Ly8gSWYgbm8gZ3JvdXAgbGVmdCwgYnVybiBvbmx5IGlmIHdpbGRjYXJkcyBleGlzdFxuXHRpZiAoc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDApIHtcblx0XHRyZXR1cm4geyBndWVzczogW10sIGJ1cm46IHRydWUgfTtcblx0fVxuXHQvLyBPdGhlcndpc2UsIHJhbmRvbSBndWVzcyBhcyBmYWxsYmFja1xuXHRyZXR1cm4ge1xuXHRcdGd1ZXNzOiBnZXRSYW5kb21FbGVtZW50cyhcblx0XHRcdHN0YXRlLndvcmRzLmZpbHRlcigodykgPT4gIXVzZWRXb3Jkcy5oYXModykpLFxuXHRcdFx0NFxuXHRcdCksXG5cdFx0YnVybjogZmFsc2UsXG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3RNb3ZlKFxuXHRkaWZmaWN1bHR5OiBCb3REaWZmaWN1bHR5LFxuXHRzdGF0ZTogUHV6emxlU3RhdGVcbik6IEJvdE1vdmUge1xuXHRzd2l0Y2ggKGRpZmZpY3VsdHkpIHtcblx0XHRjYXNlICdlYXN5Jzpcblx0XHRcdHJldHVybiBlYXN5Qm90KHN0YXRlKTtcblx0XHRjYXNlICdtZWRpdW0nOlxuXHRcdFx0cmV0dXJuIG1lZGl1bUJvdChzdGF0ZSk7XG5cdFx0Y2FzZSAnaGFyZCc6XG5cdFx0XHRyZXR1cm4gaGFyZEJvdChzdGF0ZSk7XG5cdFx0Y2FzZSAnbGVnZW5kYXJ5Jzpcblx0XHRcdHJldHVybiBsZWdlbmRhcnlCb3Qoc3RhdGUpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZWFzeUJvdChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIGJvdCBwbGF5aW5nIHRoZSBwdXp6bGUgdG8gY29tcGxldGlvbiwgcmV0dXJuaW5nIGl0cyBzb2x2ZWQgZ3JvdXBzLCBhdHRlbXB0cyBsZWZ0LCBhbmQgdGltZSB0YWtlbi5cbiAqIFVzZWQgaW4gVlNCb3RHYW1lLnRzeCBmb3IgYm90IHByb2dyZXNzIGRpc3BsYXkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5WU0JvdChcblx0cHV6emxlOiB7XG5cdFx0Z3JvdXBzOiBzdHJpbmdbXVtdO1xuXHRcdHdpbGRjYXJkcz86IHN0cmluZ1tdO1xuXHRcdHdvcmRzPzogc3RyaW5nW107XG5cdH0sXG5cdGRpZmZpY3VsdHk6IEJvdERpZmZpY3VsdHlcbik6IFByb21pc2U8e1xuXHRzb2x2ZWRHcm91cHM6IHN0cmluZ1tdW107XG5cdGF0dGVtcHRzTGVmdDogbnVtYmVyO1xuXHR0aW1lTXM6IG51bWJlcjtcbn0+IHtcblx0Ly8gR2VuZXJhdGUgd29yZHMgYXJyYXkgaWYgbm90IHByZXNlbnRcblx0Y29uc3Qgd29yZHMgPVxuXHRcdHB1enpsZS53b3JkcyAmJiBBcnJheS5pc0FycmF5KHB1enpsZS53b3Jkcylcblx0XHRcdD8gWy4uLnB1enpsZS53b3Jkc11cblx0XHRcdDogW1xuXHRcdFx0XHRcdC4uLihwdXp6bGUuZ3JvdXBzID8gcHV6emxlLmdyb3Vwcy5mbGF0KCkgOiBbXSksXG5cdFx0XHRcdFx0Li4uKHB1enpsZS53aWxkY2FyZHMgfHwgW10pLFxuXHRcdFx0ICBdO1xuXHRjb25zdCBzdGF0ZTogUHV6emxlU3RhdGUgPSB7XG5cdFx0d29yZHMsXG5cdFx0Z3JvdXBzOiBwdXp6bGUuZ3JvdXBzLFxuXHRcdGd1ZXNzZXM6IFtdLFxuXHRcdHNvbHZlZEdyb3VwczogW10sXG5cdFx0d2lsZGNhcmRzOiBbLi4uKHB1enpsZS53aWxkY2FyZHMgfHwgW10pXSxcblx0XHRhdHRlbXB0c0xlZnQ6IDQsXG5cdH07XG5cdGNvbnN0IHNvbHZlZEdyb3Vwczogc3RyaW5nW11bXSA9IFtdO1xuXHRsZXQgYXR0ZW1wdHNMZWZ0ID0gNDtcblx0Y29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXHR3aGlsZSAoXG5cdFx0c29sdmVkR3JvdXBzLmxlbmd0aCA8IHB1enpsZS5ncm91cHMubGVuZ3RoICYmXG5cdFx0YXR0ZW1wdHNMZWZ0ID4gMFxuXHQpIHtcblx0XHRjb25zdCBtb3ZlID0gZ2V0Qm90TW92ZShkaWZmaWN1bHR5LCB7XG5cdFx0XHQuLi5zdGF0ZSxcblx0XHRcdHNvbHZlZEdyb3Vwcyxcblx0XHRcdGF0dGVtcHRzTGVmdCxcblx0XHR9KTtcblx0XHRpZiAobW92ZS5ndWVzcy5sZW5ndGggPT09IDAgJiYgbW92ZS5idXJuKSB7XG5cdFx0XHQvLyBCdXJuIGEgd2lsZGNhcmQgaWYgYXZhaWxhYmxlXG5cdFx0XHRpZiAoc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0c3RhdGUud2lsZGNhcmRzLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0YXR0ZW1wdHNMZWZ0LS07XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Y29uc3QgZ3JvdXBNYXRjaCA9IHB1enpsZS5ncm91cHMuZmluZCgoZ3JvdXApID0+XG5cdFx0XHRtb3ZlLmd1ZXNzLmV2ZXJ5KCh3b3JkKSA9PiBncm91cC5pbmNsdWRlcyh3b3JkKSlcblx0XHQpO1xuXHRcdGlmIChcblx0XHRcdGdyb3VwTWF0Y2ggJiZcblx0XHRcdCFzb2x2ZWRHcm91cHMuc29tZSgoZykgPT5cblx0XHRcdFx0Zy5ldmVyeSgod29yZCkgPT4gZ3JvdXBNYXRjaC5pbmNsdWRlcyh3b3JkKSlcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdHNvbHZlZEdyb3Vwcy5wdXNoKGdyb3VwTWF0Y2gpO1xuXHRcdFx0Ly8gUmVtb3ZlIHNvbHZlZCB3b3JkcyBmcm9tIGF2YWlsYWJsZSB3b3Jkc1xuXHRcdFx0c3RhdGUud29yZHMgPSBzdGF0ZS53b3Jkcy5maWx0ZXIoXG5cdFx0XHRcdCh3KSA9PiAhZ3JvdXBNYXRjaC5pbmNsdWRlcyh3KVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXR0ZW1wdHNMZWZ0LS07XG5cdFx0fVxuXHRcdHN0YXRlLmd1ZXNzZXMucHVzaChtb3ZlLmd1ZXNzKTtcblx0fVxuXHRjb25zdCB0aW1lTXMgPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG5cdHJldHVybiB7XG5cdFx0c29sdmVkR3JvdXBzLFxuXHRcdGF0dGVtcHRzTGVmdCxcblx0XHR0aW1lTXMsXG5cdH07XG59XG4iXSwibmFtZXMiOlsiZ2V0UmFuZG9tRWxlbWVudHMiLCJhcnIiLCJuIiwic2h1ZmZsZWQiLCJzbGljZSIsInNvcnQiLCJNYXRoIiwicmFuZG9tIiwiZWFzeUJvdCIsInN0YXRlIiwiZ3Vlc3MiLCJ3b3JkcyIsImJ1cm4iLCJ3aWxkY2FyZHMiLCJsZW5ndGgiLCJtZWRpdW1Cb3QiLCJ1c2VkV29yZHMiLCJTZXQiLCJzb2x2ZWRHcm91cHMiLCJmbGF0IiwiYXZhaWxhYmxlIiwiZmlsdGVyIiwidyIsImhhcyIsImhhcmRCb3QiLCJncm91cHMiLCJncm91cCIsImV2ZXJ5IiwibGVnZW5kYXJ5Qm90IiwiZ2V0Qm90TW92ZSIsImRpZmZpY3VsdHkiLCJydW5WU0JvdCIsInB1enpsZSIsImF0dGVtcHRzTGVmdCIsInN0YXJ0IiwidGltZU1zIiwibW92ZSIsInBvcCIsImdyb3VwTWF0Y2giLCJmaW5kIiwid29yZCIsImluY2x1ZGVzIiwic29tZSIsImciLCJwdXNoIiwiZ3Vlc3NlcyIsIkFycmF5IiwiaXNBcnJheSIsIkRhdGUiLCJub3ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/vsBot.ts\n"));

/***/ })

});