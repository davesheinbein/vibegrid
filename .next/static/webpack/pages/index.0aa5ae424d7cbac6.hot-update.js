"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/vsBot.ts":
/*!****************************!*\
  !*** ./src/utils/vsBot.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBotMove: () => (/* binding */ getBotMove),\n/* harmony export */   runVSBot: () => (/* binding */ runVSBot)\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\n/* harmony import */ var _swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\n/* harmony import */ var _swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_ts_generator.js\");\n// VS Mode Bot Utility for Grid Royale\n// Supports: easy, medium, hard, legendary\n\n\n\n\n\n// --- Bot Logic for Each Difficulty ---\nfunction getRandomElements(arr, n) {\n    var shuffled = arr.slice().sort(function() {\n        return 0.5 - Math.random();\n    });\n    return shuffled.slice(0, n);\n}\nfunction easyBot(state) {\n    // Random guess, frequent mistakes, random burns\n    var guess = getRandomElements(state.words, 4);\n    var burn = Math.random() < 0.3 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction mediumBot(state) {\n    // Some logic: try to avoid obvious repeats, but still makes mistakes\n    var usedWords = new Set(state.solvedGroups.flat());\n    var available = state.words.filter(function(w) {\n        return !usedWords.has(w);\n    });\n    var guess;\n    if (Math.random() < 0.7) {\n        // Try to group by similarity (naive: first 4 unused)\n        guess = available.slice(0, 4);\n    } else {\n        // Random guess\n        guess = getRandomElements(available, 4);\n    }\n    var burn = Math.random() < 0.15 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction hardBot(state) {\n    // Pattern detection: try to find a real group, rare mistakes\n    var usedWords = new Set(state.solvedGroups.flat());\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = state.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var group = _step.value;\n            if (group.every(function(w) {\n                return !usedWords.has(w);\n            })) {\n                // Try to guess a real group\n                return {\n                    guess: group,\n                    burn: false\n                };\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // If no group found, rare random guess\n    var guess = getRandomElements(state.words.filter(function(w) {\n        return !usedWords.has(w);\n    }), 4);\n    var burn = Math.random() < 0.05 && state.wildcards.length > 0;\n    return {\n        guess: guess,\n        burn: burn\n    };\n}\nfunction legendaryBot(state) {\n    // Near-perfect logic: always finds a real group if possible\n    var usedWords = new Set(state.solvedGroups.flat());\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = state.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var group = _step.value;\n            if (group.every(function(w) {\n                return !usedWords.has(w);\n            })) {\n                return {\n                    guess: group,\n                    burn: false\n                };\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    // If no group left, burn only if wildcards exist\n    if (state.wildcards.length > 0) {\n        return {\n            guess: [],\n            burn: true\n        };\n    }\n    // Otherwise, random guess as fallback\n    return {\n        guess: getRandomElements(state.words.filter(function(w) {\n            return !usedWords.has(w);\n        }), 4),\n        burn: false\n    };\n}\nfunction getBotMove(difficulty, state) {\n    switch(difficulty){\n        case 'easy':\n            return easyBot(state);\n        case 'medium':\n            return mediumBot(state);\n        case 'hard':\n            return hardBot(state);\n        case 'legendary':\n            return legendaryBot(state);\n        default:\n            return easyBot(state);\n    }\n}\n/**\n * Simulates the bot playing the puzzle to completion, returning its solved groups, attempts left, and time taken.\n * Used in VSBotGame.tsx for bot progress display.\n */ function runVSBot(puzzle, difficulty) {\n    return _runVSBot.apply(this, arguments);\n}\nfunction _runVSBot() {\n    _runVSBot = (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_0__._)(function(puzzle, difficulty) {\n        var _loop, words, state, solvedGroups, attemptsLeft, start, timeMs;\n        return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_1__._)(this, function(_state) {\n            _loop = function() {\n                var move = getBotMove(difficulty, (0,_swc_helpers_object_spread_props__WEBPACK_IMPORTED_MODULE_2__._)((0,_swc_helpers_object_spread__WEBPACK_IMPORTED_MODULE_3__._)({}, state), {\n                    solvedGroups: solvedGroups,\n                    attemptsLeft: attemptsLeft\n                }));\n                if (move.guess.length === 0 && move.burn) {\n                    // Burn a wildcard if available\n                    if (state.wildcards.length > 0) {\n                        state.wildcards.pop();\n                    }\n                    attemptsLeft--;\n                    return \"continue\";\n                }\n                var groupMatch = puzzle.groups.find(function(group) {\n                    return move.guess.every(function(word) {\n                        return group.includes(word);\n                    });\n                });\n                if (groupMatch && !solvedGroups.some(function(g) {\n                    return g.every(function(word) {\n                        return groupMatch.includes(word);\n                    });\n                })) {\n                    solvedGroups.push(groupMatch);\n                    // Remove solved words from available words\n                    state.words = state.words.filter(function(w) {\n                        return !groupMatch.includes(w);\n                    });\n                } else {\n                    attemptsLeft--;\n                }\n                state.guesses.push(move.guess);\n            };\n            // Generate words array if not present\n            words = puzzle.words && Array.isArray(puzzle.words) ? (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.words) : (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.groups ? puzzle.groups.flat() : []).concat((0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.wildcards || []));\n            state = {\n                words: words,\n                groups: puzzle.groups,\n                guesses: [],\n                solvedGroups: [],\n                wildcards: (0,_swc_helpers_to_consumable_array__WEBPACK_IMPORTED_MODULE_4__._)(puzzle.wildcards || []),\n                attemptsLeft: 4\n            };\n            solvedGroups = [];\n            attemptsLeft = 4;\n            start = Date.now();\n            while(solvedGroups.length < puzzle.groups.length && attemptsLeft > 0)_loop();\n            timeMs = Date.now() - start;\n            return [\n                2,\n                {\n                    solvedGroups: solvedGroups,\n                    attemptsLeft: attemptsLeft,\n                    timeMs: timeMs\n                }\n            ];\n        });\n    });\n    return _runVSBot.apply(this, arguments);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWUyBNb2RlIEJvdCBVdGlsaXR5IGZvciBHcmlkIFJveWFsZVxuLy8gU3VwcG9ydHM6IGVhc3ksIG1lZGl1bSwgaGFyZCwgbGVnZW5kYXJ5XG5cbmV4cG9ydCB0eXBlIEJvdERpZmZpY3VsdHkgPVxuXHR8ICdlYXN5J1xuXHR8ICdtZWRpdW0nXG5cdHwgJ2hhcmQnXG5cdHwgJ2xlZ2VuZGFyeSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHV6emxlU3RhdGUge1xuXHR3b3Jkczogc3RyaW5nW107XG5cdGdyb3Vwczogc3RyaW5nW11bXTsgLy8gU29sdXRpb24gZ3JvdXBzXG5cdGd1ZXNzZXM6IHN0cmluZ1tdW107IC8vIFByZXZpb3VzIGd1ZXNzZXNcblx0c29sdmVkR3JvdXBzOiBzdHJpbmdbXVtdO1xuXHR3aWxkY2FyZHM6IHN0cmluZ1tdO1xuXHRhdHRlbXB0c0xlZnQ6IG51bWJlcjtcblx0Ly8gQWRkIG1vcmUgYXMgbmVlZGVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQm90TW92ZSB7XG5cdGd1ZXNzOiBzdHJpbmdbXTsgLy8gVGhlIGdyb3VwIG9mIHdvcmRzIHRvIGd1ZXNzXG5cdGJ1cm4/OiBib29sZWFuOyAvLyBXaGV0aGVyIHRvIGJ1cm4gYSB3aWxkY2FyZFxufVxuXG4vLyAtLS0gQm90IExvZ2ljIGZvciBFYWNoIERpZmZpY3VsdHkgLS0tXG5cbmZ1bmN0aW9uIGdldFJhbmRvbUVsZW1lbnRzPFQ+KGFycjogVFtdLCBuOiBudW1iZXIpOiBUW10ge1xuXHRjb25zdCBzaHVmZmxlZCA9IGFyclxuXHRcdC5zbGljZSgpXG5cdFx0LnNvcnQoKCkgPT4gMC41IC0gTWF0aC5yYW5kb20oKSk7XG5cdHJldHVybiBzaHVmZmxlZC5zbGljZSgwLCBuKTtcbn1cblxuZnVuY3Rpb24gZWFzeUJvdChzdGF0ZTogUHV6emxlU3RhdGUpOiBCb3RNb3ZlIHtcblx0Ly8gUmFuZG9tIGd1ZXNzLCBmcmVxdWVudCBtaXN0YWtlcywgcmFuZG9tIGJ1cm5zXG5cdGNvbnN0IGd1ZXNzID0gZ2V0UmFuZG9tRWxlbWVudHMoc3RhdGUud29yZHMsIDQpO1xuXHRjb25zdCBidXJuID1cblx0XHRNYXRoLnJhbmRvbSgpIDwgMC4zICYmIHN0YXRlLndpbGRjYXJkcy5sZW5ndGggPiAwO1xuXHRyZXR1cm4geyBndWVzcywgYnVybiB9O1xufVxuXG5mdW5jdGlvbiBtZWRpdW1Cb3Qoc3RhdGU6IFB1enpsZVN0YXRlKTogQm90TW92ZSB7XG5cdC8vIFNvbWUgbG9naWM6IHRyeSB0byBhdm9pZCBvYnZpb3VzIHJlcGVhdHMsIGJ1dCBzdGlsbCBtYWtlcyBtaXN0YWtlc1xuXHRjb25zdCB1c2VkV29yZHMgPSBuZXcgU2V0KHN0YXRlLnNvbHZlZEdyb3Vwcy5mbGF0KCkpO1xuXHRjb25zdCBhdmFpbGFibGUgPSBzdGF0ZS53b3Jkcy5maWx0ZXIoXG5cdFx0KHcpID0+ICF1c2VkV29yZHMuaGFzKHcpXG5cdCk7XG5cdGxldCBndWVzczogc3RyaW5nW107XG5cdGlmIChNYXRoLnJhbmRvbSgpIDwgMC43KSB7XG5cdFx0Ly8gVHJ5IHRvIGdyb3VwIGJ5IHNpbWlsYXJpdHkgKG5haXZlOiBmaXJzdCA0IHVudXNlZClcblx0XHRndWVzcyA9IGF2YWlsYWJsZS5zbGljZSgwLCA0KTtcblx0fSBlbHNlIHtcblx0XHQvLyBSYW5kb20gZ3Vlc3Ncblx0XHRndWVzcyA9IGdldFJhbmRvbUVsZW1lbnRzKGF2YWlsYWJsZSwgNCk7XG5cdH1cblx0Y29uc3QgYnVybiA9XG5cdFx0TWF0aC5yYW5kb20oKSA8IDAuMTUgJiYgc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDA7XG5cdHJldHVybiB7IGd1ZXNzLCBidXJuIH07XG59XG5cbmZ1bmN0aW9uIGhhcmRCb3Qoc3RhdGU6IFB1enpsZVN0YXRlKTogQm90TW92ZSB7XG5cdC8vIFBhdHRlcm4gZGV0ZWN0aW9uOiB0cnkgdG8gZmluZCBhIHJlYWwgZ3JvdXAsIHJhcmUgbWlzdGFrZXNcblx0Y29uc3QgdXNlZFdvcmRzID0gbmV3IFNldChzdGF0ZS5zb2x2ZWRHcm91cHMuZmxhdCgpKTtcblx0Zm9yIChjb25zdCBncm91cCBvZiBzdGF0ZS5ncm91cHMpIHtcblx0XHRpZiAoZ3JvdXAuZXZlcnkoKHcpID0+ICF1c2VkV29yZHMuaGFzKHcpKSkge1xuXHRcdFx0Ly8gVHJ5IHRvIGd1ZXNzIGEgcmVhbCBncm91cFxuXHRcdFx0cmV0dXJuIHsgZ3Vlc3M6IGdyb3VwLCBidXJuOiBmYWxzZSB9O1xuXHRcdH1cblx0fVxuXHQvLyBJZiBubyBncm91cCBmb3VuZCwgcmFyZSByYW5kb20gZ3Vlc3Ncblx0Y29uc3QgZ3Vlc3MgPSBnZXRSYW5kb21FbGVtZW50cyhcblx0XHRzdGF0ZS53b3Jkcy5maWx0ZXIoKHcpID0+ICF1c2VkV29yZHMuaGFzKHcpKSxcblx0XHQ0XG5cdCk7XG5cdGNvbnN0IGJ1cm4gPVxuXHRcdE1hdGgucmFuZG9tKCkgPCAwLjA1ICYmIHN0YXRlLndpbGRjYXJkcy5sZW5ndGggPiAwO1xuXHRyZXR1cm4geyBndWVzcywgYnVybiB9O1xufVxuXG5mdW5jdGlvbiBsZWdlbmRhcnlCb3Qoc3RhdGU6IFB1enpsZVN0YXRlKTogQm90TW92ZSB7XG5cdC8vIE5lYXItcGVyZmVjdCBsb2dpYzogYWx3YXlzIGZpbmRzIGEgcmVhbCBncm91cCBpZiBwb3NzaWJsZVxuXHRjb25zdCB1c2VkV29yZHMgPSBuZXcgU2V0KHN0YXRlLnNvbHZlZEdyb3Vwcy5mbGF0KCkpO1xuXHRmb3IgKGNvbnN0IGdyb3VwIG9mIHN0YXRlLmdyb3Vwcykge1xuXHRcdGlmIChncm91cC5ldmVyeSgodykgPT4gIXVzZWRXb3Jkcy5oYXModykpKSB7XG5cdFx0XHRyZXR1cm4geyBndWVzczogZ3JvdXAsIGJ1cm46IGZhbHNlIH07XG5cdFx0fVxuXHR9XG5cdC8vIElmIG5vIGdyb3VwIGxlZnQsIGJ1cm4gb25seSBpZiB3aWxkY2FyZHMgZXhpc3Rcblx0aWYgKHN0YXRlLndpbGRjYXJkcy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuIHsgZ3Vlc3M6IFtdLCBidXJuOiB0cnVlIH07XG5cdH1cblx0Ly8gT3RoZXJ3aXNlLCByYW5kb20gZ3Vlc3MgYXMgZmFsbGJhY2tcblx0cmV0dXJuIHtcblx0XHRndWVzczogZ2V0UmFuZG9tRWxlbWVudHMoXG5cdFx0XHRzdGF0ZS53b3Jkcy5maWx0ZXIoKHcpID0+ICF1c2VkV29yZHMuaGFzKHcpKSxcblx0XHRcdDRcblx0XHQpLFxuXHRcdGJ1cm46IGZhbHNlLFxuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90TW92ZShcblx0ZGlmZmljdWx0eTogQm90RGlmZmljdWx0eSxcblx0c3RhdGU6IFB1enpsZVN0YXRlXG4pOiBCb3RNb3ZlIHtcblx0c3dpdGNoIChkaWZmaWN1bHR5KSB7XG5cdFx0Y2FzZSAnZWFzeSc6XG5cdFx0XHRyZXR1cm4gZWFzeUJvdChzdGF0ZSk7XG5cdFx0Y2FzZSAnbWVkaXVtJzpcblx0XHRcdHJldHVybiBtZWRpdW1Cb3Qoc3RhdGUpO1xuXHRcdGNhc2UgJ2hhcmQnOlxuXHRcdFx0cmV0dXJuIGhhcmRCb3Qoc3RhdGUpO1xuXHRcdGNhc2UgJ2xlZ2VuZGFyeSc6XG5cdFx0XHRyZXR1cm4gbGVnZW5kYXJ5Qm90KHN0YXRlKTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGVhc3lCb3Qoc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSBib3QgcGxheWluZyB0aGUgcHV6emxlIHRvIGNvbXBsZXRpb24sIHJldHVybmluZyBpdHMgc29sdmVkIGdyb3VwcywgYXR0ZW1wdHMgbGVmdCwgYW5kIHRpbWUgdGFrZW4uXG4gKiBVc2VkIGluIFZTQm90R2FtZS50c3ggZm9yIGJvdCBwcm9ncmVzcyBkaXNwbGF5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuVlNCb3QoXG5cdHB1enpsZToge1xuXHRcdGdyb3Vwczogc3RyaW5nW11bXTtcblx0XHR3aWxkY2FyZHM/OiBzdHJpbmdbXTtcblx0XHR3b3Jkcz86IHN0cmluZ1tdO1xuXHR9LFxuXHRkaWZmaWN1bHR5OiBCb3REaWZmaWN1bHR5XG4pOiBQcm9taXNlPHtcblx0c29sdmVkR3JvdXBzOiBzdHJpbmdbXVtdO1xuXHRhdHRlbXB0c0xlZnQ6IG51bWJlcjtcblx0dGltZU1zOiBudW1iZXI7XG59PiB7XG5cdC8vIEdlbmVyYXRlIHdvcmRzIGFycmF5IGlmIG5vdCBwcmVzZW50XG5cdGNvbnN0IHdvcmRzID0gcHV6emxlLndvcmRzICYmIEFycmF5LmlzQXJyYXkocHV6emxlLndvcmRzKVxuXHRcdD8gWy4uLnB1enpsZS53b3Jkc11cblx0XHQ6IFtcblx0XHRcdC4uLihwdXp6bGUuZ3JvdXBzID8gcHV6emxlLmdyb3Vwcy5mbGF0KCkgOiBbXSksXG5cdFx0XHQuLi4ocHV6emxlLndpbGRjYXJkcyB8fCBbXSlcblx0XHRdO1xuXHRjb25zdCBzdGF0ZTogUHV6emxlU3RhdGUgPSB7XG5cdFx0d29yZHMsXG5cdFx0Z3JvdXBzOiBwdXp6bGUuZ3JvdXBzLFxuXHRcdGd1ZXNzZXM6IFtdLFxuXHRcdHNvbHZlZEdyb3VwczogW10sXG5cdFx0d2lsZGNhcmRzOiBbLi4uKHB1enpsZS53aWxkY2FyZHMgfHwgW10pXSxcblx0XHRhdHRlbXB0c0xlZnQ6IDQsXG5cdH07XG5cdGNvbnN0IHNvbHZlZEdyb3Vwczogc3RyaW5nW11bXSA9IFtdO1xuXHRsZXQgYXR0ZW1wdHNMZWZ0ID0gNDtcblx0Y29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXHR3aGlsZSAoc29sdmVkR3JvdXBzLmxlbmd0aCA8IHB1enpsZS5ncm91cHMubGVuZ3RoICYmIGF0dGVtcHRzTGVmdCA+IDApIHtcblx0XHRjb25zdCBtb3ZlID0gZ2V0Qm90TW92ZShkaWZmaWN1bHR5LCB7XG5cdFx0XHQuLi5zdGF0ZSxcblx0XHRcdHNvbHZlZEdyb3Vwcyxcblx0XHRcdGF0dGVtcHRzTGVmdCxcblx0XHR9KTtcblx0XHRpZiAobW92ZS5ndWVzcy5sZW5ndGggPT09IDAgJiYgbW92ZS5idXJuKSB7XG5cdFx0XHQvLyBCdXJuIGEgd2lsZGNhcmQgaWYgYXZhaWxhYmxlXG5cdFx0XHRpZiAoc3RhdGUud2lsZGNhcmRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0c3RhdGUud2lsZGNhcmRzLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0YXR0ZW1wdHNMZWZ0LS07XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Y29uc3QgZ3JvdXBNYXRjaCA9IHB1enpsZS5ncm91cHMuZmluZChcblx0XHRcdChncm91cCkgPT4gbW92ZS5ndWVzcy5ldmVyeSgod29yZCkgPT4gZ3JvdXAuaW5jbHVkZXMod29yZCkpXG5cdFx0KTtcblx0XHRpZiAoXG5cdFx0XHRncm91cE1hdGNoICYmXG5cdFx0XHQhc29sdmVkR3JvdXBzLnNvbWUoKGcpID0+IGcuZXZlcnkoKHdvcmQpID0+IGdyb3VwTWF0Y2guaW5jbHVkZXMod29yZCkpKVxuXHRcdCkge1xuXHRcdFx0c29sdmVkR3JvdXBzLnB1c2goZ3JvdXBNYXRjaCk7XG5cdFx0XHQvLyBSZW1vdmUgc29sdmVkIHdvcmRzIGZyb20gYXZhaWxhYmxlIHdvcmRzXG5cdFx0XHRzdGF0ZS53b3JkcyA9IHN0YXRlLndvcmRzLmZpbHRlcigodykgPT4gIWdyb3VwTWF0Y2guaW5jbHVkZXModykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRlbXB0c0xlZnQtLTtcblx0XHR9XG5cdFx0c3RhdGUuZ3Vlc3Nlcy5wdXNoKG1vdmUuZ3Vlc3MpO1xuXHR9XG5cdGNvbnN0IHRpbWVNcyA9IERhdGUubm93KCkgLSBzdGFydDtcblx0cmV0dXJuIHtcblx0XHRzb2x2ZWRHcm91cHMsXG5cdFx0YXR0ZW1wdHNMZWZ0LFxuXHRcdHRpbWVNcyxcblx0fTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRSYW5kb21FbGVtZW50cyIsImFyciIsIm4iLCJzaHVmZmxlZCIsInNsaWNlIiwic29ydCIsIk1hdGgiLCJyYW5kb20iLCJlYXN5Qm90Iiwic3RhdGUiLCJndWVzcyIsIndvcmRzIiwiYnVybiIsIndpbGRjYXJkcyIsImxlbmd0aCIsIm1lZGl1bUJvdCIsInVzZWRXb3JkcyIsIlNldCIsInNvbHZlZEdyb3VwcyIsImZsYXQiLCJhdmFpbGFibGUiLCJmaWx0ZXIiLCJ3IiwiaGFzIiwiaGFyZEJvdCIsImdyb3VwcyIsImdyb3VwIiwiZXZlcnkiLCJsZWdlbmRhcnlCb3QiLCJnZXRCb3RNb3ZlIiwiZGlmZmljdWx0eSIsInJ1blZTQm90IiwicHV6emxlIiwiYXR0ZW1wdHNMZWZ0Iiwic3RhcnQiLCJ0aW1lTXMiLCJtb3ZlIiwicG9wIiwiZ3JvdXBNYXRjaCIsImZpbmQiLCJ3b3JkIiwiaW5jbHVkZXMiLCJzb21lIiwiZyIsInB1c2giLCJndWVzc2VzIiwiQXJyYXkiLCJpc0FycmF5IiwiRGF0ZSIsIm5vdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/vsBot.ts\n"));

/***/ })

});